# Database

Design specification for the database backend that will eventually
be used for the occupant-query server.

## Needs

The occupant-query server needs to be able to effectively model three
main relationships:

- `URL <-> Query ID(s)`
- `Query ID <-> Question Text`
- `Query ID <-> Response(s)`

Because we would like to be able to change which question(s) correspond
to which URLs, as well as be able to modify question details atomically,
it is important that URLs and questions be functionally separate entities.

## Proposed Model

The aforementioned abstraction is best achieved by thee separate tables.
Inkeeping with the terminology used elsewhere in this project, we will
refer to the `URL <-> Query ID(s)` mapping as the `deployments` table, the
`Query ID <-> Question Text` mapping as the `questions` table, and the
`Query ID <-> Response(s)` as the `responses` table.

The `deployments` table should consist of a `url` column, and a `query_id`
column, with the unique key being the `url` to `query_id` mapping.

|     url     |   query_id   |
| ----------- | ------------ |
| building_1  | temp_query   |
| building_1  | light_query  |
| ...         | ...          |


The `questions` table should consist of a `query_id` column and a
`question_text` column, with the `query_id` acting as the unique key.

|  query_id   |  question_text |
| ----------- | -------------- |
| temp_query  | "How Hot?"     |
| light_query | "How Bright?"  |
| ...         | ...            |

Finally, the `responses` table should consist of a `query_id` column,
a `response_text` column, and a `response_value` column, with the
unique key being the `query_id` to `response_text` mapping.

|   query_id   |  response_text  |  response_value  |
| ------------ | --------------- | ---------------- |
| temp_query   | "Very Hot"      | + 4              |
| temp_query   | "Very Cold"     | - 4              |
| temp_query   | "Comfortable"   |   0              |
| ...          | ...             | ...              |


## Server Interaction

In order to assemble the necessary data to fulfill an http request,
the server will first need to query the `deployments` table in order
to ascertain all `query_id` values which are currently active for the
url at which the request was given.  Once all `query_id` values are known,
the server must then query the `questions` and `responses` tables for all
values corresponding to one of the active queries.  Finally, the server
must compile this data into a JSON encoded string which can be passed to
the elm app for display.

*Note:* Because there may be some latency generated by the heavy database
usage that this interaction entails, it may be optimal to have the elm app
be served immediately, without waiting for the query results, and then register a
request with the server, asking for its deployment details.
